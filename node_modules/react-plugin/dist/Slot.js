'use strict';
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
exports.__esModule = true;
exports.Slot = void 0;
var linked_list_1 = __importDefault(require('@skidding/linked-list'));
var react_1 = __importDefault(require('react'));
var PlugConnect_1 = require('./PlugConnect');
var slotContexts_1 = require('./slotContexts');
var useSlotPlugs_1 = require('./useSlotPlugs');
function Slot(_a) {
  var children = _a.children,
    name = _a.name,
    _b = _a.slotProps,
    slotProps = _b === void 0 ? {} : _b;
  var plugs = useSlotPlugs_1.useSlotPlugs(name);
  var _c = slotContexts_1.getSlotContext(name),
    Provider = _c.Provider,
    Consumer = _c.Consumer;
  return (
    // Children are either
    // - passed to the next plug or,
    // - if this is the last plug for this slot, rendered directly.
    react_1['default'].createElement(Consumer, null, function (linkedSlotItem) {
      if (linkedSlotItem === void 0) {
        linkedSlotItem = getFirstLinkedPlug(plugs);
      }
      var plug = linkedSlotItem.value,
        next = linkedSlotItem.next;
      // All registered plugs for this slot have been rendered (for
      // now). More plugs for this slot can be registered later, which
      // will re-render all plugs from scratch.
      if (!plug) return children;
      var pluginName = plug.pluginName,
        component = plug.component;
      return react_1['default'].createElement(
        Provider,
        { value: next() },
        react_1['default'].createElement(
          PlugConnect_1.PlugConnect,
          {
            pluginName: pluginName,
            component: component,
            slotProps: slotProps,
          },
          children,
        ),
      );
    })
  );
}
exports.Slot = Slot;
function getFirstLinkedPlug(plugs) {
  // Plugs are traversed in the order they're applied. But this doesn't mean
  // top-down from a component hierarchy point of view. The traversal of the
  // plugs can go up and down the component hierachy repeatedly, based on the
  // type of each plug and how they end up composing together.
  return linked_list_1['default'](plugs);
}
