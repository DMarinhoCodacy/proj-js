"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
exports.__esModule = true;
exports.createPluginContext = void 0;
var pluginContextCache_1 = require("./pluginContextCache");
var pluginMethodsCache_1 = require("./pluginMethodsCache");
var pluginStore_1 = require("./pluginStore");
var shared_1 = require("./shared");
function createPluginContext(pluginName, sharedContext) {
    var _a = pluginStore_1.getPlugin(pluginName), enabled = _a.enabled, defaultConfig = _a.defaultConfig, initialState = _a.initialState;
    if (!enabled)
        throw Error("Plugin is disabled: " + pluginName);
    var cachedContext = pluginContextCache_1.getCachedPluginContext(pluginName, sharedContext);
    if (cachedContext)
        return cachedContext;
    function getConfig() {
        if (!defaultConfig)
            throw Error("Plugin doesn't have config: " + pluginName);
        return sharedContext.config[pluginName];
    }
    function getState() {
        if (!initialState)
            throw Error("Plugin doesn't have state: " + pluginName);
        return sharedContext.state[pluginName];
    }
    function setState(newState, cb) {
        if (!initialState)
            throw Error("Plugin doesn't have state: " + pluginName);
        sharedContext.setState(pluginName, newState);
        pluginStore_1.emitPluginStateChange();
        if (cb)
            cb();
    }
    function emit(eventName) {
        var eventArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            eventArgs[_i - 1] = arguments[_i];
        }
        var eventKey = shared_1.getEventKey(pluginName, eventName);
        var plugins = pluginStore_1.getPlugins();
        Object.keys(plugins).forEach(function (otherPluginName) {
            var listener = plugins[otherPluginName];
            if (listener.enabled && listener.eventHandlers[eventKey])
                listener.eventHandlers[eventKey].forEach(function (handler) {
                    handler.apply(void 0, __spreadArrays([createPluginContext(otherPluginName, sharedContext)], eventArgs));
                });
        });
    }
    var getMethodsOf = function (otherPluginName) {
        return createPluginMethods(otherPluginName, sharedContext);
    };
    var context = {
        pluginName: pluginName,
        getConfig: getConfig,
        getState: getState,
        setState: setState,
        getMethodsOf: getMethodsOf,
        emit: emit
    };
    pluginContextCache_1.cachePluginContext(pluginName, sharedContext, context);
    return context;
}
exports.createPluginContext = createPluginContext;
function createPluginMethods(pluginName, sharedContext) {
    var context = createPluginContext(pluginName, sharedContext);
    var cachedMethods = pluginMethodsCache_1.getCachedPluginMethods(pluginName, context);
    if (cachedMethods)
        return cachedMethods;
    var methodHandlers = pluginStore_1.getPlugin(pluginName).methodHandlers;
    var methods = Object.keys(methodHandlers).reduce(function (acc, methodName) {
        var _a;
        return (__assign(__assign({}, acc), (_a = {}, _a[methodName] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return methodHandlers[methodName].apply(methodHandlers, __spreadArrays([context], args));
        }, _a)));
    }, {});
    pluginMethodsCache_1.cachePluginMethods(pluginName, context, methods);
    return methods;
}
